#### [600. 不含连续1的非负整数](https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/)(难题)

tag：dp

给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含 **连续的1** 的个数。

**示例 1:**

```
输入: 5
输出: 5
解释: 
下面是带有相应二进制表示的非负整数<= 5：
0 : 0
1 : 1
2 : 10
3 : 11
4 : 100
5 : 101
其中，只有整数3违反规则（有两个连续的1），其他5个满足规则。
```

**说明:** 1 <= n <= 109

 答案引用自wisdompeak：



```cpp
class Solution {
public:
    int findIntegers(int num) 
    {        
        if (num==0) return 0;
        if (num==1) return 2;
        
        vector<int>f(33);
        f[0]=1;
        f[1]=2;
        for (int i=2; i<32; i++)        
            f[i]=f[i-2]+f[i-1];        
        
        vector<int>digits(32,0);
        for (int i=0; i<32; i++)    
            digits[i]=((num>>i)&1);   
        
        int count=0;
        for (int i=31; i>=0; i--)
        {
            if (digits[i]==0) continue;
            
            // 第i位取0
            count+=f[i-1+1];  
            
            // 第i位取1
            if (i-1>=0 && digits[i-1]==1)
            {
                count+=f[i-2+1];
                return count;
            }
        }
        
        count++;
        
        return count;
        
    }
};
```



先考虑一个简单的问题：对于一个n位的01字符串，没有连续1的排列有多少？这是一个简单的DP问题。考虑dp[i]时，如果第i位是0，则1～i-1位可以自由排列为任何无连续1的组合，即dp[i-1]。如果第i位是1，则第i-1位只能是0，那么从1～i-2位可以自由排列为任何无连续1的组合，即dp[i-2].所以动态转移方程是：

dp[i]=dp[i-1]+dp[i-2]

注意初始条件，dp[0]=1, dp[1]=2; dp[0]是起辅助作用。

那么对于本题而言，我们先将num转化为二进制的字符串。

考虑第i位是1的情况： ***1xxxxxxxxxx，那么如果保留所有的*且第i位取0，那么第i+1～n位可以自由排列为任何无连续1的组合，都是小于***1xxxxxxxxxx的，即有dp[n-i]个; 如果第i位取1，那么就要继续查看后面的数组才能保证不大于num。

比如，假设往后看到 ***101xxxxxxxx， 即第i+2位是1（隔了一个0），那么可以重复之前的分析：保留所有*，将第i+2位取0，则有dp[n-i-2]种排列，它们满足小于***101xxxxxxxx，且无连续1的条件；如果将第i+2位取1，则需要继续往后查看。

但是，如果看到第i+1位出现了这种情况：***11xxxxxxxxx，即第i+1位和第i位一样都是1。注意到，第i+1位是不能取1的（否则连续两个1），所以第i+1位只能取0，这样则有dp[n-i-1]种组合符合要求。但特别注意，num在第i+1位之后的数字我们其实就不用查看了，因为第i+1位已经锁定为0了，这样的01组合一定小于等于num。此时就要退出循环。

注意一个细节：如果num从头到尾都没有任何连续的1出现，那么最后就要把result++，因为虽然一路都是把当前位的取值等同于digits[i]，但最后并没有包含num本身。